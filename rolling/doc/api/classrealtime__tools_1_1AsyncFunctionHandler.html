<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ros2_control - rolling: realtime_tools::AsyncFunctionHandler&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_ros-controls_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ros2_control - rolling
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerealtime__tools.html">realtime_tools</a></li><li class="navelem"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">AsyncFunctionHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrealtime__tools_1_1AsyncFunctionHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">realtime_tools::AsyncFunctionHandler&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to handle asynchronous function calls. <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is a class that allows the user to have a asynchronous call to the parsed method and be able to set some thread specific parameters.  
 <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async__function__handler_8hpp_source.html">async_function_handler.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac29f057a9794d4383b271f15348e6a60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac29f057a9794d4383b271f15348e6a60">init</a> (std::function&lt; T(const rclcpp::Time &amp;, const rclcpp::Duration &amp;)&gt; callback, int thread_priority=50)</td></tr>
<tr class="memdesc:ac29f057a9794d4383b271f15348e6a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> with the callback and thread_priority.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac29f057a9794d4383b271f15348e6a60">More...</a><br /></td></tr>
<tr class="separator:ac29f057a9794d4383b271f15348e6a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472ecb59df2bc496c0f1e4031ce6c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a472ecb59df2bc496c0f1e4031ce6c7c5">init</a> (std::function&lt; T(const rclcpp::Time &amp;, const rclcpp::Duration &amp;)&gt; callback, std::function&lt; bool()&gt; trigger_predicate, int thread_priority=50)</td></tr>
<tr class="memdesc:a472ecb59df2bc496c0f1e4031ce6c7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> with the callback, trigger_predicate and thread_priority.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a472ecb59df2bc496c0f1e4031ce6c7c5">More...</a><br /></td></tr>
<tr class="separator:a472ecb59df2bc496c0f1e4031ce6c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea09da4a6639d1f24ba3950f9c3715c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#afea09da4a6639d1f24ba3950f9c3715c">trigger_async_callback</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period)</td></tr>
<tr class="memdesc:afea09da4a6639d1f24ba3950f9c3715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the async callback method cycle.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#afea09da4a6639d1f24ba3950f9c3715c">More...</a><br /></td></tr>
<tr class="separator:afea09da4a6639d1f24ba3950f9c3715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68fcfa6a7c2f3b214898ce023f413b7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#af68fcfa6a7c2f3b214898ce023f413b7">get_last_return_value</a> () const</td></tr>
<tr class="memdesc:af68fcfa6a7c2f3b214898ce023f413b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last return value of the async callback method.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#af68fcfa6a7c2f3b214898ce023f413b7">More...</a><br /></td></tr>
<tr class="separator:af68fcfa6a7c2f3b214898ce023f413b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11ae1a70137f94962c697bb675f8917"><td class="memItemLeft" align="right" valign="top">const rclcpp::Time &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac11ae1a70137f94962c697bb675f8917">get_current_callback_time</a> () const</td></tr>
<tr class="memdesc:ac11ae1a70137f94962c697bb675f8917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current callback time.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac11ae1a70137f94962c697bb675f8917">More...</a><br /></td></tr>
<tr class="separator:ac11ae1a70137f94962c697bb675f8917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafe59816a046a8ef8e07ec73d702aba"><td class="memItemLeft" align="right" valign="top">const rclcpp::Duration &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#acafe59816a046a8ef8e07ec73d702aba">get_current_callback_period</a> () const</td></tr>
<tr class="memdesc:acafe59816a046a8ef8e07ec73d702aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current callback period.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#acafe59816a046a8ef8e07ec73d702aba">More...</a><br /></td></tr>
<tr class="separator:acafe59816a046a8ef8e07ec73d702aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef8e189833741c203d64a62ecb72952"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a4ef8e189833741c203d64a62ecb72952">reset_variables</a> ()</td></tr>
<tr class="memdesc:a4ef8e189833741c203d64a62ecb72952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal variables of the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a>.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a4ef8e189833741c203d64a62ecb72952">More...</a><br /></td></tr>
<tr class="separator:a4ef8e189833741c203d64a62ecb72952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2112028c20c4efaf1fcb407df0889559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a2112028c20c4efaf1fcb407df0889559">wait_for_trigger_cycle_to_finish</a> ()</td></tr>
<tr class="memdesc:a2112028c20c4efaf1fcb407df0889559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until the current async callback method trigger cycle is finished.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a2112028c20c4efaf1fcb407df0889559">More...</a><br /></td></tr>
<tr class="separator:a2112028c20c4efaf1fcb407df0889559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa236dd4d561028160e4ec5c3f93f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#aefa236dd4d561028160e4ec5c3f93f03">is_initialized</a> () const</td></tr>
<tr class="memdesc:aefa236dd4d561028160e4ec5c3f93f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is initialized.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#aefa236dd4d561028160e4ec5c3f93f03">More...</a><br /></td></tr>
<tr class="separator:aefa236dd4d561028160e4ec5c3f93f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac65dbf23b53e03f99e842ae8375b2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#acac65dbf23b53e03f99e842ae8375b2c">join_async_callback_thread</a> ()</td></tr>
<tr class="memdesc:acac65dbf23b53e03f99e842ae8375b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the async callback thread.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#acac65dbf23b53e03f99e842ae8375b2c">More...</a><br /></td></tr>
<tr class="separator:acac65dbf23b53e03f99e842ae8375b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cdf96e23ae62a3fdb4586023f00a71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a64cdf96e23ae62a3fdb4586023f00a71">is_running</a> () const</td></tr>
<tr class="memdesc:a64cdf96e23ae62a3fdb4586023f00a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the async worker thread is running.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a64cdf96e23ae62a3fdb4586023f00a71">More...</a><br /></td></tr>
<tr class="separator:a64cdf96e23ae62a3fdb4586023f00a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1a48bddba7e13894292201fa943c0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#ada1a48bddba7e13894292201fa943c0d">is_stopped</a> () const</td></tr>
<tr class="memdesc:ada1a48bddba7e13894292201fa943c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the async callback is triggered to stop the cycle.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#ada1a48bddba7e13894292201fa943c0d">More...</a><br /></td></tr>
<tr class="separator:ada1a48bddba7e13894292201fa943c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c57e241daa000b5c398e65095616e3"><td class="memItemLeft" align="right" valign="top">std::thread &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac2c57e241daa000b5c398e65095616e3">get_thread</a> ()</td></tr>
<tr class="memdesc:ac2c57e241daa000b5c398e65095616e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the async worker thread.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac2c57e241daa000b5c398e65095616e3">More...</a><br /></td></tr>
<tr class="separator:ac2c57e241daa000b5c398e65095616e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0f08ab20a00a8dcf4017b826bb2900"><td class="memItemLeft" align="right" valign="top">const std::thread &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a6a0f08ab20a00a8dcf4017b826bb2900">get_thread</a> () const</td></tr>
<tr class="memdesc:a6a0f08ab20a00a8dcf4017b826bb2900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the const version of async worker thread.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a6a0f08ab20a00a8dcf4017b826bb2900">More...</a><br /></td></tr>
<tr class="separator:a6a0f08ab20a00a8dcf4017b826bb2900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbf1c3b006b37730a18b1831e41f6af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a2bbf1c3b006b37730a18b1831e41f6af">is_trigger_cycle_in_progress</a> () const</td></tr>
<tr class="memdesc:a2bbf1c3b006b37730a18b1831e41f6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the async callback method is in progress.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a2bbf1c3b006b37730a18b1831e41f6af">More...</a><br /></td></tr>
<tr class="separator:a2bbf1c3b006b37730a18b1831e41f6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac450b4737a3a04464a8d5e3588eb154d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac450b4737a3a04464a8d5e3588eb154d">stop_thread</a> ()</td></tr>
<tr class="memdesc:ac450b4737a3a04464a8d5e3588eb154d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the callback thread.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#ac450b4737a3a04464a8d5e3588eb154d">More...</a><br /></td></tr>
<tr class="separator:ac450b4737a3a04464a8d5e3588eb154d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e0de8d9b70df3cae92f4ea9986c150"><td class="memItemLeft" align="right" valign="top">std::chrono::nanoseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a39e0de8d9b70df3cae92f4ea9986c150">get_last_execution_time</a> () const</td></tr>
<tr class="memdesc:a39e0de8d9b70df3cae92f4ea9986c150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last execution time of the async callback method.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a39e0de8d9b70df3cae92f4ea9986c150">More...</a><br /></td></tr>
<tr class="separator:a39e0de8d9b70df3cae92f4ea9986c150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44234723688cafc7fe05012256e9ae88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html#a44234723688cafc7fe05012256e9ae88">start_thread</a> ()</td></tr>
<tr class="memdesc:a44234723688cafc7fe05012256e9ae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and starts the callback thread.  <a href="classrealtime__tools_1_1AsyncFunctionHandler.html#a44234723688cafc7fe05012256e9ae88">More...</a><br /></td></tr>
<tr class="separator:a44234723688cafc7fe05012256e9ae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class realtime_tools::AsyncFunctionHandler&lt; T &gt;</h3>

<p>Class to handle asynchronous function calls. <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is a class that allows the user to have a asynchronous call to the parsed method and be able to set some thread specific parameters. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acafe59816a046a8ef8e07ec73d702aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafe59816a046a8ef8e07ec73d702aba">&#9670;&nbsp;</a></span>get_current_callback_period()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rclcpp::Duration&amp; <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::get_current_callback_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current callback period. </p>
<dl class="section return"><dt>Returns</dt><dd>The current callback period </dd></dl>

</div>
</div>
<a id="ac11ae1a70137f94962c697bb675f8917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11ae1a70137f94962c697bb675f8917">&#9670;&nbsp;</a></span>get_current_callback_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const rclcpp::Time&amp; <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::get_current_callback_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current callback time. </p>
<dl class="section return"><dt>Returns</dt><dd>The current callback time </dd></dl>

</div>
</div>
<a id="a39e0de8d9b70df3cae92f4ea9986c150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0de8d9b70df3cae92f4ea9986c150">&#9670;&nbsp;</a></span>get_last_execution_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::nanoseconds <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::get_last_execution_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last execution time of the async callback method. </p>
<dl class="section return"><dt>Returns</dt><dd>The last execution time of the async callback method in nanoseconds </dd></dl>

</div>
</div>
<a id="af68fcfa6a7c2f3b214898ce023f413b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68fcfa6a7c2f3b214898ce023f413b7">&#9670;&nbsp;</a></span>get_last_return_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::get_last_return_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last return value of the async callback method. </p>
<dl class="section return"><dt>Returns</dt><dd>The last return value of the async callback method </dd></dl>

</div>
</div>
<a id="ac2c57e241daa000b5c398e65095616e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c57e241daa000b5c398e65095616e3">&#9670;&nbsp;</a></span>get_thread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread&amp; <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::get_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the async worker thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The async callback thread </dd></dl>

</div>
</div>
<a id="a6a0f08ab20a00a8dcf4017b826bb2900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0f08ab20a00a8dcf4017b826bb2900">&#9670;&nbsp;</a></span>get_thread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::thread&amp; <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::get_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the const version of async worker thread. </p>
<dl class="section return"><dt>Returns</dt><dd>The async callback thread </dd></dl>

</div>
</div>
<a id="ac29f057a9794d4383b271f15348e6a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29f057a9794d4383b271f15348e6a60">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; T(const rclcpp::Time &amp;, const rclcpp::Duration &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread_priority</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> with the callback and thread_priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function that will be called asynchronously If the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is already initialized and is running, it will throw a runtime error. If the parsed functions are not valid, it will throw a runtime error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a472ecb59df2bc496c0f1e4031ce6c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472ecb59df2bc496c0f1e4031ce6c7c5">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; T(const rclcpp::Time &amp;, const rclcpp::Duration &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool()&gt;&#160;</td>
          <td class="paramname"><em>trigger_predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thread_priority</em> = <code>50</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> with the callback, trigger_predicate and thread_priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function that will be called asynchronously. </td></tr>
    <tr><td class="paramname">trigger_predicate</td><td>Predicate function that will be called to check if the async callback method should be triggered or not. </td></tr>
    <tr><td class="paramname">thread_priority</td><td>Priority of the async worker thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The parsed trigger_predicate should be free from any concurrency issues. It is expected to be both thread-safe and reentrant.</dd></dl>
<p>If the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is already initialized and is running, it will throw a runtime error. If the parsed functions are not valid, it will throw a runtime error. </p>

</div>
</div>
<a id="aefa236dd4d561028160e4ec5c3f93f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa236dd4d561028160e4ec5c3f93f03">&#9670;&nbsp;</a></span>is_initialized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::is_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is initialized. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is initialized, false otherwise </dd></dl>

</div>
</div>
<a id="a64cdf96e23ae62a3fdb4586023f00a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cdf96e23ae62a3fdb4586023f00a71">&#9670;&nbsp;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::is_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the async worker thread is running. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the async worker thread is running, false otherwise </dd></dl>

</div>
</div>
<a id="ada1a48bddba7e13894292201fa943c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1a48bddba7e13894292201fa943c0d">&#9670;&nbsp;</a></span>is_stopped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::is_stopped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the async callback is triggered to stop the cycle. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the async callback is requested to be stopped, false otherwise </dd></dl>

</div>
</div>
<a id="a2bbf1c3b006b37730a18b1831e41f6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbf1c3b006b37730a18b1831e41f6af">&#9670;&nbsp;</a></span>is_trigger_cycle_in_progress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::is_trigger_cycle_in_progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the async callback method is in progress. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the async callback method is in progress, false otherwise </dd></dl>

</div>
</div>
<a id="acac65dbf23b53e03f99e842ae8375b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac65dbf23b53e03f99e842ae8375b2c">&#9670;&nbsp;</a></span>join_async_callback_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::join_async_callback_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join the async callback thread. </p>
<p>If the async method is running, it will join the async thread. If the async method is not running, it will return immediately. </p>

</div>
</div>
<a id="a4ef8e189833741c203d64a62ecb72952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef8e189833741c203d64a62ecb72952">&#9670;&nbsp;</a></span>reset_variables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::reset_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the internal variables of the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a>. </p>
<p>A method to reset the internal variables of the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a>. It will reset the async callback return value, exception pointer, and the trigger status.</p>
<dl class="section note"><dt>Note</dt><dd>This method should be invoked after catching an exception in the async callback thread, to be able to trigger the async callback method again. </dd></dl>

</div>
</div>
<a id="a44234723688cafc7fe05012256e9ae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44234723688cafc7fe05012256e9ae88">&#9670;&nbsp;</a></span>start_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::start_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes and starts the callback thread. </p>
<p>If the worker thread is not running, it will start the async callback thread. If the worker thread is already configured and running, does nothing and returns immediately. </p>

</div>
</div>
<a id="ac450b4737a3a04464a8d5e3588eb154d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac450b4737a3a04464a8d5e3588eb154d">&#9670;&nbsp;</a></span>stop_thread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::stop_thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the callback thread. </p>
<p>If the async method is running, it will notify the async thread to stop and then joins the async thread. </p>

</div>
</div>
<a id="afea09da4a6639d1f24ba3950f9c3715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea09da4a6639d1f24ba3950f9c3715c">&#9670;&nbsp;</a></span>trigger_async_callback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, T&gt; <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::trigger_async_callback </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triggers the async callback method cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Current time </td></tr>
    <tr><td class="paramname">period</td><td>Current period </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with the first element being a boolean indicating if the async callback method was triggered and the second element being the last return value of the async function. If the <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html" title="Class to handle asynchronous function calls. AsyncFunctionHandler is a class that allows the user to ...">AsyncFunctionHandler</a> is not initialized properly, it will throw a runtime error. If the callback method is waiting for the trigger, it will notify the async thread to start the callback. If the async callback method is still running, it will return the last return value from the last trigger cycle.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If an exception is caught in the async callback thread, it will be rethrown in the current thread, so in order to have the trigger_async_callback method working again, the exception should be caught and the <code>reset_variables</code> method should be invoked.</dd>
<dd>
In the case of controllers, The controller manager is responsible for triggering and maintaining the controller's update rate, as it should be only acting as a scheduler. Same applies to the resource manager when handling the hardware components. </dd></dl>

</div>
</div>
<a id="a2112028c20c4efaf1fcb407df0889559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2112028c20c4efaf1fcb407df0889559">&#9670;&nbsp;</a></span>wait_for_trigger_cycle_to_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrealtime__tools_1_1AsyncFunctionHandler.html">realtime_tools::AsyncFunctionHandler</a>&lt; T &gt;::wait_for_trigger_cycle_to_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until the current async callback method trigger cycle is finished. </p>
<p>If the async method is running, it will wait for the current async method call to finish. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>realtime_tools/include/realtime_tools/<a class="el" href="async__function__handler_8hpp_source.html">async_function_handler.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
