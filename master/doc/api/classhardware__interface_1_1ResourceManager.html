<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ros2_control - rolling: hardware_interface::ResourceManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_ros-controls_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ros2_control - rolling
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehardware__interface.html">hardware_interface</a></li><li class="navelem"><a class="el" href="classhardware__interface_1_1ResourceManager.html">ResourceManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classhardware__interface_1_1ResourceManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hardware_interface::ResourceManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for hardware_interface::ResourceManager:</div>
<div class="dyncontent">
<div class="center"><img src="classhardware__interface_1_1ResourceManager__inherit__graph.png" border="0" usemap="#ahardware__interface_1_1ResourceManager_inherit__map" alt="Inheritance graph"/></div>
<map name="ahardware__interface_1_1ResourceManager_inherit__map" id="ahardware__interface_1_1ResourceManager_inherit__map">
<area shape="rect" title=" " alt="" coords="37,5,185,47"/>
<area shape="rect" href="classgz__ros2__control_1_1GZResourceManager.html" title=" " alt="" coords="5,95,216,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa90371cc7efda31ff0385578ae1af565"><td class="memItemLeft" align="right" valign="top"><a id="aa90371cc7efda31ff0385578ae1af565"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#aa90371cc7efda31ff0385578ae1af565">ResourceManager</a> (rclcpp::node_interfaces::NodeClockInterface::SharedPtr clock_interface=nullptr)</td></tr>
<tr class="memdesc:aa90371cc7efda31ff0385578ae1af565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for the Resource Manager. <br /></td></tr>
<tr class="separator:aa90371cc7efda31ff0385578ae1af565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c507a9e1521051914330ff411eadad7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a0c507a9e1521051914330ff411eadad7">ResourceManager</a> (const std::string &amp;urdf, bool activate_all=false, const unsigned int update_rate=100, rclcpp::node_interfaces::NodeClockInterface::SharedPtr clock_interface=nullptr)</td></tr>
<tr class="memdesc:a0c507a9e1521051914330ff411eadad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the Resource Manager.  <a href="classhardware__interface_1_1ResourceManager.html#a0c507a9e1521051914330ff411eadad7">More...</a><br /></td></tr>
<tr class="separator:a0c507a9e1521051914330ff411eadad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ac95fd198f60a0eb9f83c2fbcd2799"><td class="memItemLeft" align="right" valign="top"><a id="a01ac95fd198f60a0eb9f83c2fbcd2799"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ResourceManager</b> (const <a class="el" href="classhardware__interface_1_1ResourceManager.html">ResourceManager</a> &amp;)=delete</td></tr>
<tr class="separator:a01ac95fd198f60a0eb9f83c2fbcd2799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154b8ff2aa3100affdbb4c374fa4bbcc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a154b8ff2aa3100affdbb4c374fa4bbcc">load_and_initialize_components</a> (const std::string &amp;urdf, const unsigned int update_rate=100)</td></tr>
<tr class="memdesc:a154b8ff2aa3100affdbb4c374fa4bbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load resources from on a given URDF.  <a href="classhardware__interface_1_1ResourceManager.html#a154b8ff2aa3100affdbb4c374fa4bbcc">More...</a><br /></td></tr>
<tr class="separator:a154b8ff2aa3100affdbb4c374fa4bbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd1dad46c65fd87dd99696f574936c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a25bd1dad46c65fd87dd99696f574936c">are_components_initialized</a> () const</td></tr>
<tr class="memdesc:a25bd1dad46c65fd87dd99696f574936c"><td class="mdescLeft">&#160;</td><td class="mdescRight">if the resource manager load_and_initialize_components(...) function has been called this returns true. We want to permit to loading the urdf later on, but we currently don't want to permit multiple calls to load_and_initialize_components (reloading/loading different urdf).  <a href="classhardware__interface_1_1ResourceManager.html#a25bd1dad46c65fd87dd99696f574936c">More...</a><br /></td></tr>
<tr class="separator:a25bd1dad46c65fd87dd99696f574936c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19fb1fec871e9567cc9b84388f60a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhardware__interface_1_1LoanedStateInterface.html">LoanedStateInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#af19fb1fec871e9567cc9b84388f60a12">claim_state_interface</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:af19fb1fec871e9567cc9b84388f60a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim a state interface given its key.  <a href="classhardware__interface_1_1ResourceManager.html#af19fb1fec871e9567cc9b84388f60a12">More...</a><br /></td></tr>
<tr class="separator:af19fb1fec871e9567cc9b84388f60a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e7ea08d55ba05bc1039eac996feb7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a59e7ea08d55ba05bc1039eac996feb7b">state_interface_keys</a> () const</td></tr>
<tr class="memdesc:a59e7ea08d55ba05bc1039eac996feb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all registered state interfaces keys.  <a href="classhardware__interface_1_1ResourceManager.html#a59e7ea08d55ba05bc1039eac996feb7b">More...</a><br /></td></tr>
<tr class="separator:a59e7ea08d55ba05bc1039eac996feb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf95e636f5534b884d49fdde504c16d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#acbf95e636f5534b884d49fdde504c16d">available_state_interfaces</a> () const</td></tr>
<tr class="memdesc:acbf95e636f5534b884d49fdde504c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all available state interfaces keys.  <a href="classhardware__interface_1_1ResourceManager.html#acbf95e636f5534b884d49fdde504c16d">More...</a><br /></td></tr>
<tr class="separator:acbf95e636f5534b884d49fdde504c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ff82a7fe5138487e4e3b5fc9d2dcfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a79ff82a7fe5138487e4e3b5fc9d2dcfc">state_interface_is_available</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a79ff82a7fe5138487e4e3b5fc9d2dcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a state interface is available under the given key.  <a href="classhardware__interface_1_1ResourceManager.html#a79ff82a7fe5138487e4e3b5fc9d2dcfc">More...</a><br /></td></tr>
<tr class="separator:a79ff82a7fe5138487e4e3b5fc9d2dcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8741d23a22b3218679b5a05bb83b3b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a8741d23a22b3218679b5a05bb83b3b01">import_controller_exported_state_interfaces</a> (const std::string &amp;controller_name, std::vector&lt; <a class="el" href="classhardware__interface_1_1StateInterface.html">StateInterface</a> &gt; &amp;interfaces)</td></tr>
<tr class="memdesc:a8741d23a22b3218679b5a05bb83b3b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add controllers' exported state interfaces to resource manager.  <a href="classhardware__interface_1_1ResourceManager.html#a8741d23a22b3218679b5a05bb83b3b01">More...</a><br /></td></tr>
<tr class="separator:a8741d23a22b3218679b5a05bb83b3b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6d77e04a0495013f7298e5327f417b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a7b6d77e04a0495013f7298e5327f417b">get_controller_exported_state_interface_names</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a7b6d77e04a0495013f7298e5327f417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of exported tate interface of a controller.  <a href="classhardware__interface_1_1ResourceManager.html#a7b6d77e04a0495013f7298e5327f417b">More...</a><br /></td></tr>
<tr class="separator:a7b6d77e04a0495013f7298e5327f417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431ff81eb02b9d55722d121b45213b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a431ff81eb02b9d55722d121b45213b99">make_controller_exported_state_interfaces_available</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a431ff81eb02b9d55722d121b45213b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add controller's exported state interfaces to available list.  <a href="classhardware__interface_1_1ResourceManager.html#a431ff81eb02b9d55722d121b45213b99">More...</a><br /></td></tr>
<tr class="separator:a431ff81eb02b9d55722d121b45213b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a748a8f197a043a740d0d8e0ba847a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a6a748a8f197a043a740d0d8e0ba847a1">make_controller_exported_state_interfaces_unavailable</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a6a748a8f197a043a740d0d8e0ba847a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove controller's exported state interface to available list.  <a href="classhardware__interface_1_1ResourceManager.html#a6a748a8f197a043a740d0d8e0ba847a1">More...</a><br /></td></tr>
<tr class="separator:a6a748a8f197a043a740d0d8e0ba847a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8e38222b8162d65ab853fe24d489fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a3c8e38222b8162d65ab853fe24d489fc">remove_controller_exported_state_interfaces</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a3c8e38222b8162d65ab853fe24d489fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove controllers exported state interfaces from resource manager.  <a href="classhardware__interface_1_1ResourceManager.html#a3c8e38222b8162d65ab853fe24d489fc">More...</a><br /></td></tr>
<tr class="separator:a3c8e38222b8162d65ab853fe24d489fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ce6015d9870f44dc62c94b729615de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a73ce6015d9870f44dc62c94b729615de">import_controller_reference_interfaces</a> (const std::string &amp;controller_name, std::vector&lt; <a class="el" href="classhardware__interface_1_1CommandInterface.html">CommandInterface</a> &gt; &amp;interfaces)</td></tr>
<tr class="memdesc:a73ce6015d9870f44dc62c94b729615de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add controllers' reference interfaces to resource manager.  <a href="classhardware__interface_1_1ResourceManager.html#a73ce6015d9870f44dc62c94b729615de">More...</a><br /></td></tr>
<tr class="separator:a73ce6015d9870f44dc62c94b729615de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616c7be6c65aa774fa4e65a76292dbd1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a616c7be6c65aa774fa4e65a76292dbd1">get_controller_reference_interface_names</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a616c7be6c65aa774fa4e65a76292dbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of reference interface of a controller.  <a href="classhardware__interface_1_1ResourceManager.html#a616c7be6c65aa774fa4e65a76292dbd1">More...</a><br /></td></tr>
<tr class="separator:a616c7be6c65aa774fa4e65a76292dbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d241e770ccba51ce6599568cfc25ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a03d241e770ccba51ce6599568cfc25ee">make_controller_reference_interfaces_available</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a03d241e770ccba51ce6599568cfc25ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add controller's reference interface to available list.  <a href="classhardware__interface_1_1ResourceManager.html#a03d241e770ccba51ce6599568cfc25ee">More...</a><br /></td></tr>
<tr class="separator:a03d241e770ccba51ce6599568cfc25ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957c1ae8d36cda4631a5206ad5faff60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a957c1ae8d36cda4631a5206ad5faff60">make_controller_reference_interfaces_unavailable</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:a957c1ae8d36cda4631a5206ad5faff60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove controller's reference interface to available list.  <a href="classhardware__interface_1_1ResourceManager.html#a957c1ae8d36cda4631a5206ad5faff60">More...</a><br /></td></tr>
<tr class="separator:a957c1ae8d36cda4631a5206ad5faff60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa169723dd5cab86ea38e8eb08d5bec06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#aa169723dd5cab86ea38e8eb08d5bec06">remove_controller_reference_interfaces</a> (const std::string &amp;controller_name)</td></tr>
<tr class="memdesc:aa169723dd5cab86ea38e8eb08d5bec06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove controllers reference interfaces from resource manager.  <a href="classhardware__interface_1_1ResourceManager.html#aa169723dd5cab86ea38e8eb08d5bec06">More...</a><br /></td></tr>
<tr class="separator:aa169723dd5cab86ea38e8eb08d5bec06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd2b8965df0a5eff2bac71ad80f1c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#aebd2b8965df0a5eff2bac71ad80f1c22">cache_controller_to_hardware</a> (const std::string &amp;controller_name, const std::vector&lt; std::string &gt; &amp;interfaces)</td></tr>
<tr class="memdesc:aebd2b8965df0a5eff2bac71ad80f1c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache mapping between hardware and controllers using it.  <a href="classhardware__interface_1_1ResourceManager.html#aebd2b8965df0a5eff2bac71ad80f1c22">More...</a><br /></td></tr>
<tr class="separator:aebd2b8965df0a5eff2bac71ad80f1c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74df02b374391ed286443e2f64f4e497"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a74df02b374391ed286443e2f64f4e497">get_cached_controllers_to_hardware</a> (const std::string &amp;hardware_name)</td></tr>
<tr class="memdesc:a74df02b374391ed286443e2f64f4e497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cached controllers for a specific hardware.  <a href="classhardware__interface_1_1ResourceManager.html#a74df02b374391ed286443e2f64f4e497">More...</a><br /></td></tr>
<tr class="separator:a74df02b374391ed286443e2f64f4e497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7a585a53874e549bd8b252e5432f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a1ad7a585a53874e549bd8b252e5432f0">command_interface_is_claimed</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a1ad7a585a53874e549bd8b252e5432f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a command interface is already claimed.  <a href="classhardware__interface_1_1ResourceManager.html#a1ad7a585a53874e549bd8b252e5432f0">More...</a><br /></td></tr>
<tr class="separator:a1ad7a585a53874e549bd8b252e5432f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50232b53f388de3620f7e90889c48c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhardware__interface_1_1LoanedCommandInterface.html">LoanedCommandInterface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#ae50232b53f388de3620f7e90889c48c3">claim_command_interface</a> (const std::string &amp;key)</td></tr>
<tr class="memdesc:ae50232b53f388de3620f7e90889c48c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim a command interface given its key.  <a href="classhardware__interface_1_1ResourceManager.html#ae50232b53f388de3620f7e90889c48c3">More...</a><br /></td></tr>
<tr class="separator:ae50232b53f388de3620f7e90889c48c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c6b58e58c87d0d16cb2926e6a3c59b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a10c6b58e58c87d0d16cb2926e6a3c59b">command_interface_keys</a> () const</td></tr>
<tr class="memdesc:a10c6b58e58c87d0d16cb2926e6a3c59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all registered command interfaces keys.  <a href="classhardware__interface_1_1ResourceManager.html#a10c6b58e58c87d0d16cb2926e6a3c59b">More...</a><br /></td></tr>
<tr class="separator:a10c6b58e58c87d0d16cb2926e6a3c59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12aa4b0368fab0200703f879be6f9a2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#aa12aa4b0368fab0200703f879be6f9a2">available_command_interfaces</a> () const</td></tr>
<tr class="memdesc:aa12aa4b0368fab0200703f879be6f9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all available command interfaces keys.  <a href="classhardware__interface_1_1ResourceManager.html#aa12aa4b0368fab0200703f879be6f9a2">More...</a><br /></td></tr>
<tr class="separator:aa12aa4b0368fab0200703f879be6f9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656d4da9c850338fcba1de2868967bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a656d4da9c850338fcba1de2868967bfb">command_interface_is_available</a> (const std::string &amp;interface) const</td></tr>
<tr class="memdesc:a656d4da9c850338fcba1de2868967bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a command interface is available under the given name.  <a href="classhardware__interface_1_1ResourceManager.html#a656d4da9c850338fcba1de2868967bfb">More...</a><br /></td></tr>
<tr class="separator:a656d4da9c850338fcba1de2868967bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c46cc8f9dcd2b0ad28dad9e6019c80"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a95c46cc8f9dcd2b0ad28dad9e6019c80">actuator_components_size</a> () const</td></tr>
<tr class="memdesc:a95c46cc8f9dcd2b0ad28dad9e6019c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number size_t of loaded actuator components.  <a href="classhardware__interface_1_1ResourceManager.html#a95c46cc8f9dcd2b0ad28dad9e6019c80">More...</a><br /></td></tr>
<tr class="separator:a95c46cc8f9dcd2b0ad28dad9e6019c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b471feb94ef2463c222ae69f25888d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a52b471feb94ef2463c222ae69f25888d">sensor_components_size</a> () const</td></tr>
<tr class="memdesc:a52b471feb94ef2463c222ae69f25888d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of loaded sensor components.  <a href="classhardware__interface_1_1ResourceManager.html#a52b471feb94ef2463c222ae69f25888d">More...</a><br /></td></tr>
<tr class="separator:a52b471feb94ef2463c222ae69f25888d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b97b997de12432dcbfbabcedca2a52e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a5b97b997de12432dcbfbabcedca2a52e">system_components_size</a> () const</td></tr>
<tr class="memdesc:a5b97b997de12432dcbfbabcedca2a52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of loaded system components.  <a href="classhardware__interface_1_1ResourceManager.html#a5b97b997de12432dcbfbabcedca2a52e">More...</a><br /></td></tr>
<tr class="separator:a5b97b997de12432dcbfbabcedca2a52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe79c9a6d49491475723bd832513f8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a3fe79c9a6d49491475723bd832513f8d">import_component</a> (std::unique_ptr&lt; <a class="el" href="classhardware__interface_1_1ActuatorInterface.html">ActuatorInterface</a> &gt; actuator, const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a> &amp;hardware_info)</td></tr>
<tr class="memdesc:a3fe79c9a6d49491475723bd832513f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a hardware component which is not listed in the URDF.  <a href="classhardware__interface_1_1ResourceManager.html#a3fe79c9a6d49491475723bd832513f8d">More...</a><br /></td></tr>
<tr class="separator:a3fe79c9a6d49491475723bd832513f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f2e8d8fd1bfbd52ca5d14487e704cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a68f2e8d8fd1bfbd52ca5d14487e704cf">import_component</a> (std::unique_ptr&lt; <a class="el" href="classhardware__interface_1_1SensorInterface.html">SensorInterface</a> &gt; sensor, const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a> &amp;hardware_info)</td></tr>
<tr class="memdesc:a68f2e8d8fd1bfbd52ca5d14487e704cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a hardware component which is not listed in the URDF.  <a href="classhardware__interface_1_1ResourceManager.html#a68f2e8d8fd1bfbd52ca5d14487e704cf">More...</a><br /></td></tr>
<tr class="separator:a68f2e8d8fd1bfbd52ca5d14487e704cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bc2b4c6b3e60bde2a5e5235e0a758a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#aa6bc2b4c6b3e60bde2a5e5235e0a758a">import_component</a> (std::unique_ptr&lt; <a class="el" href="classhardware__interface_1_1SystemInterface.html">SystemInterface</a> &gt; system, const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a> &amp;hardware_info)</td></tr>
<tr class="memdesc:aa6bc2b4c6b3e60bde2a5e5235e0a758a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a hardware component which is not listed in the URDF.  <a href="classhardware__interface_1_1ResourceManager.html#aa6bc2b4c6b3e60bde2a5e5235e0a758a">More...</a><br /></td></tr>
<tr class="separator:aa6bc2b4c6b3e60bde2a5e5235e0a758a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed4684c2857e7267a9527087d036fe9"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="structhardware__interface_1_1HardwareComponentInfo.html">HardwareComponentInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a3ed4684c2857e7267a9527087d036fe9">get_components_status</a> ()</td></tr>
<tr class="memdesc:a3ed4684c2857e7267a9527087d036fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return status for all components.  <a href="classhardware__interface_1_1ResourceManager.html#a3ed4684c2857e7267a9527087d036fe9">More...</a><br /></td></tr>
<tr class="separator:a3ed4684c2857e7267a9527087d036fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa777c95ad1ebc43bcf5d080c28edcd0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#aa777c95ad1ebc43bcf5d080c28edcd0d">prepare_command_mode_switch</a> (const std::vector&lt; std::string &gt; &amp;start_interfaces, const std::vector&lt; std::string &gt; &amp;stop_interfaces)</td></tr>
<tr class="memdesc:aa777c95ad1ebc43bcf5d080c28edcd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the hardware components for a new command interface mode.  <a href="classhardware__interface_1_1ResourceManager.html#aa777c95ad1ebc43bcf5d080c28edcd0d">More...</a><br /></td></tr>
<tr class="separator:aa777c95ad1ebc43bcf5d080c28edcd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf26a674896c9d29bd3509159f20248"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#acbf26a674896c9d29bd3509159f20248">perform_command_mode_switch</a> (const std::vector&lt; std::string &gt; &amp;start_interfaces, const std::vector&lt; std::string &gt; &amp;stop_interfaces)</td></tr>
<tr class="memdesc:acbf26a674896c9d29bd3509159f20248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the hardware components that realtime hardware mode switching should occur.  <a href="classhardware__interface_1_1ResourceManager.html#acbf26a674896c9d29bd3509159f20248">More...</a><br /></td></tr>
<tr class="separator:acbf26a674896c9d29bd3509159f20248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d11cea529a849400a6a885fc9f8a64"><td class="memItemLeft" align="right" valign="top">return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a20d11cea529a849400a6a885fc9f8a64">set_component_state</a> (const std::string &amp;component_name, rclcpp_lifecycle::State &amp;target_state)</td></tr>
<tr class="memdesc:a20d11cea529a849400a6a885fc9f8a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets state of hardware component.  <a href="classhardware__interface_1_1ResourceManager.html#a20d11cea529a849400a6a885fc9f8a64">More...</a><br /></td></tr>
<tr class="separator:a20d11cea529a849400a6a885fc9f8a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ed439caa61b262898b51681b68417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a282ed439caa61b262898b51681b68417">shutdown_async_components</a> ()</td></tr>
<tr class="memdesc:a282ed439caa61b262898b51681b68417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all async components from the resource storage.  <a href="classhardware__interface_1_1ResourceManager.html#a282ed439caa61b262898b51681b68417">More...</a><br /></td></tr>
<tr class="separator:a282ed439caa61b262898b51681b68417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe34534b983c80a80cb501d8ab837c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhardware__interface_1_1HardwareReadWriteStatus.html">HardwareReadWriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a9fe34534b983c80a80cb501d8ab837c7">read</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period)</td></tr>
<tr class="memdesc:a9fe34534b983c80a80cb501d8ab837c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all loaded hardware components.  <a href="classhardware__interface_1_1ResourceManager.html#a9fe34534b983c80a80cb501d8ab837c7">More...</a><br /></td></tr>
<tr class="separator:a9fe34534b983c80a80cb501d8ab837c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cbef1c78b8b5357c0b8e8d97cb077e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhardware__interface_1_1HardwareReadWriteStatus.html">HardwareReadWriteStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#af2cbef1c78b8b5357c0b8e8d97cb077e">write</a> (const rclcpp::Time &amp;time, const rclcpp::Duration &amp;period)</td></tr>
<tr class="memdesc:af2cbef1c78b8b5357c0b8e8d97cb077e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all loaded hardware components.  <a href="classhardware__interface_1_1ResourceManager.html#af2cbef1c78b8b5357c0b8e8d97cb077e">More...</a><br /></td></tr>
<tr class="separator:af2cbef1c78b8b5357c0b8e8d97cb077e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a951f065e9b797984178e55ede21e3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a1a951f065e9b797984178e55ede21e3f">command_interface_exists</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a1a951f065e9b797984178e55ede21e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a command interface is registered under the given key.  <a href="classhardware__interface_1_1ResourceManager.html#a1a951f065e9b797984178e55ede21e3f">More...</a><br /></td></tr>
<tr class="separator:a1a951f065e9b797984178e55ede21e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3728e8bbc327359fc54b43f5602928"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhardware__interface_1_1ResourceManager.html#a8a3728e8bbc327359fc54b43f5602928">state_interface_exists</a> (const std::string &amp;key) const</td></tr>
<tr class="memdesc:a8a3728e8bbc327359fc54b43f5602928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a state interface is registered under the given key.  <a href="classhardware__interface_1_1ResourceManager.html#a8a3728e8bbc327359fc54b43f5602928">More...</a><br /></td></tr>
<tr class="separator:a8a3728e8bbc327359fc54b43f5602928"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acddd6537df2c16637d995fc9144b7ac5"><td class="memItemLeft" align="right" valign="top"><a id="acddd6537df2c16637d995fc9144b7ac5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>components_are_loaded_and_initialized_</b> = false</td></tr>
<tr class="separator:acddd6537df2c16637d995fc9144b7ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc61035073fa62a342b47861b4557ae"><td class="memItemLeft" align="right" valign="top"><a id="acbc61035073fa62a342b47861b4557ae"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>resource_interfaces_lock_</b></td></tr>
<tr class="separator:acbc61035073fa62a342b47861b4557ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0a60770623f74349718a760517cbf"><td class="memItemLeft" align="right" valign="top"><a id="a9bc0a60770623f74349718a760517cbf"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>claimed_command_interfaces_lock_</b></td></tr>
<tr class="separator:a9bc0a60770623f74349718a760517cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679050b8cf46c8b0086173943fa20e3e"><td class="memItemLeft" align="right" valign="top"><a id="a679050b8cf46c8b0086173943fa20e3e"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>resources_lock_</b></td></tr>
<tr class="separator:a679050b8cf46c8b0086173943fa20e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0c507a9e1521051914330ff411eadad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c507a9e1521051914330ff411eadad7">&#9670;&nbsp;</a></span>ResourceManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hardware_interface::ResourceManager::ResourceManager </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>urdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>activate_all</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>update_rate</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp::node_interfaces::NodeClockInterface::SharedPtr&#160;</td>
          <td class="paramname"><em>clock_interface</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the Resource Manager. </p>
<p>The implementation loads the specified urdf and initializes the hardware components listed within as well as populate their respective state and command interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">urdf</td><td>string containing the URDF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">activate_all</td><td>boolean argument indicating if all resources should be immediately activated. Currently used only in tests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_rate</td><td>Update rate of the controller manager to calculate calling frequency of async components. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clock_interface</td><td>reference to the clock interface of the CM node for getting time used for triggering async components. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a95c46cc8f9dcd2b0ad28dad9e6019c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c46cc8f9dcd2b0ad28dad9e6019c80">&#9670;&nbsp;</a></span>actuator_components_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hardware_interface::ResourceManager::actuator_components_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number size_t of loaded actuator components. </p>
<dl class="section return"><dt>Returns</dt><dd>number of actuator components. </dd></dl>

</div>
</div>
<a id="a25bd1dad46c65fd87dd99696f574936c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bd1dad46c65fd87dd99696f574936c">&#9670;&nbsp;</a></span>are_components_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::are_components_initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if the resource manager load_and_initialize_components(...) function has been called this returns true. We want to permit to loading the urdf later on, but we currently don't want to permit multiple calls to load_and_initialize_components (reloading/loading different urdf). </p>
<dl class="section return"><dt>Returns</dt><dd>true if the resource manager has successfully loaded and initialized the components </dd>
<dd>
false if the resource manager doesn't have any components loaded and initialized. </dd></dl>

</div>
</div>
<a id="aa12aa4b0368fab0200703f879be6f9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12aa4b0368fab0200703f879be6f9a2">&#9670;&nbsp;</a></span>available_command_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::available_command_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all available command interfaces keys. </p>
<p>The keys are collected from the available list. </p><dl class="section return"><dt>Returns</dt><dd>vector of strings, containing all available command interface names. </dd></dl>

</div>
</div>
<a id="acbf95e636f5534b884d49fdde504c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf95e636f5534b884d49fdde504c16d">&#9670;&nbsp;</a></span>available_state_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::available_state_interfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all available state interfaces keys. </p>
<p>The keys are collected from the available list. </p><dl class="section return"><dt>Returns</dt><dd>Vector of strings, containing all available state interface names. </dd></dl>

</div>
</div>
<a id="aebd2b8965df0a5eff2bac71ad80f1c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd2b8965df0a5eff2bac71ad80f1c22">&#9670;&nbsp;</a></span>cache_controller_to_hardware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::cache_controller_to_hardware </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>interfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cache mapping between hardware and controllers using it. </p>
<p>Find mapping between controller and hardware based on interfaces controller with <code>controller_name</code> is using and cache those for later usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which interfaces are provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaces</td><td>list of interfaces controller with <code>controller_name</code> is using. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae50232b53f388de3620f7e90889c48c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50232b53f388de3620f7e90889c48c3">&#9670;&nbsp;</a></span>claim_command_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhardware__interface_1_1LoanedCommandInterface.html">LoanedCommandInterface</a> hardware_interface::ResourceManager::claim_command_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim a command interface given its key. </p>
<p>The resource is claimed as long as being in scope. Once the resource is going out of scope, the destructor returns and thus frees the resource to claimed by others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>String identifier which command interface to claim </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>command interface </dd></dl>

</div>
</div>
<a id="af19fb1fec871e9567cc9b84388f60a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19fb1fec871e9567cc9b84388f60a12">&#9670;&nbsp;</a></span>claim_state_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhardware__interface_1_1LoanedStateInterface.html">LoanedStateInterface</a> hardware_interface::ResourceManager::claim_state_interface </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim a state interface given its key. </p>
<p>The resource is claimed as long as being in scope. Once the resource is going out of scope, the destructor returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>String identifier which state interface to claim </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>state interface </dd></dl>

</div>
</div>
<a id="a1a951f065e9b797984178e55ede21e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a951f065e9b797984178e55ede21e3f">&#9670;&nbsp;</a></span>command_interface_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::command_interface_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a command interface is registered under the given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>string identifying the interface to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if interface exist, false otherwise. </dd></dl>

</div>
</div>
<a id="a656d4da9c850338fcba1de2868967bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656d4da9c850338fcba1de2868967bfb">&#9670;&nbsp;</a></span>command_interface_is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::command_interface_is_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a command interface is available under the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>string identifying the interface to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if interface is available, false otherwise. </dd></dl>

</div>
</div>
<a id="a1ad7a585a53874e549bd8b252e5432f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad7a585a53874e549bd8b252e5432f0">&#9670;&nbsp;</a></span>command_interface_is_claimed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::command_interface_is_claimed </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a command interface is already claimed. </p>
<p>Any command interface can only be claimed by a single instance. </p><dl class="section note"><dt>Note</dt><dd>the equivalent function does not exist for state interfaces. These are solely read-only and can thus be used by multiple instances.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>string identifying the interface to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if interface is already claimed, false if available. </dd></dl>

</div>
</div>
<a id="a10c6b58e58c87d0d16cb2926e6a3c59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c6b58e58c87d0d16cb2926e6a3c59b">&#9670;&nbsp;</a></span>command_interface_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::command_interface_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all registered command interfaces keys. </p>
<p>The keys are collected from each loaded hardware component. </p><dl class="section return"><dt>Returns</dt><dd>vector of strings, containing all registered keys. </dd></dl>

</div>
</div>
<a id="a74df02b374391ed286443e2f64f4e497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74df02b374391ed286443e2f64f4e497">&#9670;&nbsp;</a></span>get_cached_controllers_to_hardware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::get_cached_controllers_to_hardware </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>hardware_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return cached controllers for a specific hardware. </p>
<p>Return list of cached controller names that use the hardware with name <code>hardware_name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hardware_name</td><td>the name of the hardware for which cached controllers should be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of cached controller names that depend on hardware with name <code>hardware_name</code>. </dd></dl>

</div>
</div>
<a id="a3ed4684c2857e7267a9527087d036fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed4684c2857e7267a9527087d036fe9">&#9670;&nbsp;</a></span>get_components_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, <a class="el" href="structhardware__interface_1_1HardwareComponentInfo.html">HardwareComponentInfo</a> &gt; hardware_interface::ResourceManager::get_components_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return status for all components. </p>
<dl class="section return"><dt>Returns</dt><dd>map of hardware names and their status. </dd></dl>

</div>
</div>
<a id="a7b6d77e04a0495013f7298e5327f417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6d77e04a0495013f7298e5327f417b">&#9670;&nbsp;</a></span>get_controller_exported_state_interface_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::get_controller_exported_state_interface_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of exported tate interface of a controller. </p>
<p>Returns lists of stored exported state interfaces names for a controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>for which list of state interface names is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of reference interface names. </dd></dl>

</div>
</div>
<a id="a616c7be6c65aa774fa4e65a76292dbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616c7be6c65aa774fa4e65a76292dbd1">&#9670;&nbsp;</a></span>get_controller_reference_interface_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::get_controller_reference_interface_names </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of reference interface of a controller. </p>
<p>Returns lists of stored reference interfaces names for a controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>for which list of reference interface names is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of reference interface names. </dd></dl>

</div>
</div>
<a id="a3fe79c9a6d49491475723bd832513f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe79c9a6d49491475723bd832513f8d">&#9670;&nbsp;</a></span>import_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::import_component </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classhardware__interface_1_1ActuatorInterface.html">ActuatorInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>actuator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>hardware_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a hardware component which is not listed in the URDF. </p>
<p>Components which are initialized outside a URDF can be added post initialization. Nevertheless, there should still be <code><a class="el" href="structhardware__interface_1_1HardwareInfo.html" title="This structure stores information about hardware defined in a robot&#39;s URDF.">HardwareInfo</a></code> available for this component, either parsed from a URDF string (easiest) or filled manually.</p>
<dl class="section note"><dt>Note</dt><dd>this might invalidate existing state and command interfaces and should thus not be called when a controller is running. </dd>
<dd>
given that no hardware_info is available, the component has to be configured externally and prior to the call to import. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actuator</td><td>pointer to the actuator interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hardware_info</td><td>hardware info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68f2e8d8fd1bfbd52ca5d14487e704cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f2e8d8fd1bfbd52ca5d14487e704cf">&#9670;&nbsp;</a></span>import_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::import_component </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classhardware__interface_1_1SensorInterface.html">SensorInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>sensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>hardware_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a hardware component which is not listed in the URDF. </p>
<p>Components which are initialized outside a URDF can be added post initialization. Nevertheless, there should still be <code><a class="el" href="structhardware__interface_1_1HardwareInfo.html" title="This structure stores information about hardware defined in a robot&#39;s URDF.">HardwareInfo</a></code> available for this component, either parsed from a URDF string (easiest) or filled manually.</p>
<dl class="section note"><dt>Note</dt><dd>this might invalidate existing state and command interfaces and should thus not be called when a controller is running. </dd>
<dd>
given that no hardware_info is available, the component has to be configured externally and prior to the call to import. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sensor</td><td>pointer to the sensor interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hardware_info</td><td>hardware info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6bc2b4c6b3e60bde2a5e5235e0a758a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bc2b4c6b3e60bde2a5e5235e0a758a">&#9670;&nbsp;</a></span>import_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::import_component </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classhardware__interface_1_1SystemInterface.html">SystemInterface</a> &gt;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhardware__interface_1_1HardwareInfo.html">HardwareInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>hardware_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a hardware component which is not listed in the URDF. </p>
<p>Components which are initialized outside a URDF can be added post initialization. Nevertheless, there should still be <code><a class="el" href="structhardware__interface_1_1HardwareInfo.html" title="This structure stores information about hardware defined in a robot&#39;s URDF.">HardwareInfo</a></code> available for this component, either parsed from a URDF string (easiest) or filled manually.</p>
<dl class="section note"><dt>Note</dt><dd>this might invalidate existing state and command interfaces and should thus not be called when a controller is running. </dd>
<dd>
given that no hardware_info is available, the component has to be configured externally and prior to the call to import. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">system</td><td>pointer to the system interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hardware_info</td><td>hardware info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8741d23a22b3218679b5a05bb83b3b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8741d23a22b3218679b5a05bb83b3b01">&#9670;&nbsp;</a></span>import_controller_exported_state_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::import_controller_exported_state_interfaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhardware__interface_1_1StateInterface.html">StateInterface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>interfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add controllers' exported state interfaces to resource manager. </p>
<p>Interface for transferring management of exported state interfaces to resource manager. When chaining controllers, state interfaces are used by the preceding controllers. Therefore, they should be managed in the same way as state interface of hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which state interfaces are imported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaces</td><td>list of controller's state interfaces as StateInterfaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ce6015d9870f44dc62c94b729615de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ce6015d9870f44dc62c94b729615de">&#9670;&nbsp;</a></span>import_controller_reference_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::import_controller_reference_interfaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classhardware__interface_1_1CommandInterface.html">CommandInterface</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>interfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add controllers' reference interfaces to resource manager. </p>
<p>Interface for transferring management of reference interfaces to resource manager. When chaining controllers, reference interfaces are used as command interface of preceding controllers. Therefore, they should be managed in the same way as command interface of hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which reference interfaces are imported. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaces</td><td>list of controller's reference interfaces as CommandInterfaces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a154b8ff2aa3100affdbb4c374fa4bbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154b8ff2aa3100affdbb4c374fa4bbcc">&#9670;&nbsp;</a></span>load_and_initialize_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::load_and_initialize_components </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>urdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>update_rate</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load resources from on a given URDF. </p>
<p>The resource manager can be post-initialized with a given URDF. This is mainly used in conjunction with the default constructor in which the URDF might not be present at first initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">urdf</td><td>string containing the URDF. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_rate</td><td>update rate of the main control loop, i.e., of the controller manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if URDF validation has failed. </dd></dl>

<p>Reimplemented in <a class="el" href="classgz__ros2__control_1_1GZResourceManager.html#a56f6ac17faaf4f57495980d3c44a8618">gz_ros2_control::GZResourceManager</a>.</p>

</div>
</div>
<a id="a431ff81eb02b9d55722d121b45213b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431ff81eb02b9d55722d121b45213b99">&#9670;&nbsp;</a></span>make_controller_exported_state_interfaces_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::make_controller_exported_state_interfaces_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add controller's exported state interfaces to available list. </p>
<p>Adds state interfacess of a controller with given name to the available list. This method should be called when a controller gets activated with chained mode turned on. That means, the controller's exported state interfaces can be used by another controllers in chained architectures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which interfaces should become available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a748a8f197a043a740d0d8e0ba847a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a748a8f197a043a740d0d8e0ba847a1">&#9670;&nbsp;</a></span>make_controller_exported_state_interfaces_unavailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::make_controller_exported_state_interfaces_unavailable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove controller's exported state interface to available list. </p>
<p>Removes interfaces of a controller with given name from the available list. This method should be called when a controller gets deactivated and its reference interfaces cannot be used by another controller anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which interfaces should become unavailable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d241e770ccba51ce6599568cfc25ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d241e770ccba51ce6599568cfc25ee">&#9670;&nbsp;</a></span>make_controller_reference_interfaces_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::make_controller_reference_interfaces_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add controller's reference interface to available list. </p>
<p>Adds interfaces of a controller with given name to the available list. This method should be called when a controller gets activated with chained mode turned on. That means, the controller's reference interfaces can be used by another controller in chained architectures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which interfaces should become available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a957c1ae8d36cda4631a5206ad5faff60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957c1ae8d36cda4631a5206ad5faff60">&#9670;&nbsp;</a></span>make_controller_reference_interfaces_unavailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::make_controller_reference_interfaces_unavailable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove controller's reference interface to available list. </p>
<p>Removes interfaces of a controller with given name from the available list. This method should be called when a controller gets deactivated and its reference interfaces cannot be used by another controller anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>name of the controller which interfaces should become unavailable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbf26a674896c9d29bd3509159f20248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf26a674896c9d29bd3509159f20248">&#9670;&nbsp;</a></span>perform_command_mode_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::perform_command_mode_switch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_interfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>stop_interfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the hardware components that realtime hardware mode switching should occur. </p>
<p>Hardware components are asked to perform the command interface mode switching.</p>
<dl class="section note"><dt>Note</dt><dd>this is intended for mode-switching when a hardware interface needs to change control mode depending on which command interface is claimed. </dd>
<dd>
this is for realtime switching of the command interface. </dd>
<dd>
it is assumed that <code>prepare_command_mode_switch</code> is called just before this method with the same input arguments. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_interfaces</td><td>vector of string identifiers for the command interfaces starting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_interfaces</td><td>vector of string identifiers for the command interfaces stopping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if switch is performed, false if a component rejects switching. </dd></dl>

</div>
</div>
<a id="aa777c95ad1ebc43bcf5d080c28edcd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa777c95ad1ebc43bcf5d080c28edcd0d">&#9670;&nbsp;</a></span>prepare_command_mode_switch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::prepare_command_mode_switch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>start_interfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>stop_interfaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the hardware components for a new command interface mode. </p>
<p>Hardware components are asked to prepare a new command interface claim.</p>
<dl class="section note"><dt>Note</dt><dd>this is intended for mode-switching when a hardware interface needs to change control mode depending on which command interface is claimed. </dd>
<dd>
this is for non-realtime preparing for and accepting new command resource combinations. </dd>
<dd>
accept_command_resource_claim is called on all actuators and system components and hardware interfaces should return hardware_interface::return_type::OK by default </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start_interfaces</td><td>vector of string identifiers for the command interfaces starting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop_interfaces</td><td>vector of string identifiers for the command interfaces stopping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if switch can be prepared; false if a component rejects switch request, and if at least one of the input interfaces are not existing or not available (i.e., component is not in ACTIVE or INACTIVE state). </dd></dl>

</div>
</div>
<a id="a9fe34534b983c80a80cb501d8ab837c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe34534b983c80a80cb501d8ab837c7">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhardware__interface_1_1HardwareReadWriteStatus.html">HardwareReadWriteStatus</a> hardware_interface::ResourceManager::read </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all loaded hardware components. </p>
<p>Reads from all active hardware components.</p>
<p>Part of the real-time critical update loop. It is realtime-safe if used hardware interfaces are implemented adequately. </p>

</div>
</div>
<a id="a3c8e38222b8162d65ab853fe24d489fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8e38222b8162d65ab853fe24d489fc">&#9670;&nbsp;</a></span>remove_controller_exported_state_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::remove_controller_exported_state_interfaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove controllers exported state interfaces from resource manager. </p>
<p>Remove exported state interfaces from resource manager, i.e., resource storage. The interfaces will be deleted from all internal maps and lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>list of interface names that will be deleted from resource manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa169723dd5cab86ea38e8eb08d5bec06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa169723dd5cab86ea38e8eb08d5bec06">&#9670;&nbsp;</a></span>remove_controller_reference_interfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::remove_controller_reference_interfaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>controller_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove controllers reference interfaces from resource manager. </p>
<p>Remove reference interfaces from resource manager, i.e., resource storage. The interfaces will be deleted from all internal maps and lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">controller_name</td><td>list of interface names that will be deleted from resource manager. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b471feb94ef2463c222ae69f25888d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b471feb94ef2463c222ae69f25888d">&#9670;&nbsp;</a></span>sensor_components_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hardware_interface::ResourceManager::sensor_components_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of loaded sensor components. </p>
<dl class="section return"><dt>Returns</dt><dd>number of sensor components. </dd></dl>

</div>
</div>
<a id="a20d11cea529a849400a6a885fc9f8a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20d11cea529a849400a6a885fc9f8a64">&#9670;&nbsp;</a></span>set_component_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return_type hardware_interface::ResourceManager::set_component_state </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>component_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rclcpp_lifecycle::State &amp;&#160;</td>
          <td class="paramname"><em>target_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets state of hardware component. </p>
<p>Set set of hardware component if possible. Takes care of all transitions needed to reach the target state. It implements the state machine from: <a href="https://design.ros2.org/articles/node_lifecycle.html">https://design.ros2.org/articles/node_lifecycle.html</a></p>
<p>The method is not part of the real-time critical update loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">component_name</td><td>component name to change state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_state</td><td>target state to set for a hardware component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware_interface::retun_type::OK if component successfully switched its state and hardware_interface::return_type::ERROR any of state transitions has failed. </dd></dl>

</div>
</div>
<a id="a282ed439caa61b262898b51681b68417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282ed439caa61b262898b51681b68417">&#9670;&nbsp;</a></span>shutdown_async_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hardware_interface::ResourceManager::shutdown_async_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all async components from the resource storage. </p>
<p>Needed to join the threads immediately after the control loop is ended. </p>

</div>
</div>
<a id="a8a3728e8bbc327359fc54b43f5602928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3728e8bbc327359fc54b43f5602928">&#9670;&nbsp;</a></span>state_interface_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::state_interface_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a state interface is registered under the given key. </p>
<dl class="section return"><dt>Returns</dt><dd>true if interface exist, false otherwise. </dd></dl>

</div>
</div>
<a id="a79ff82a7fe5138487e4e3b5fc9d2dcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ff82a7fe5138487e4e3b5fc9d2dcfc">&#9670;&nbsp;</a></span>state_interface_is_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hardware_interface::ResourceManager::state_interface_is_available </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a state interface is available under the given key. </p>
<dl class="section return"><dt>Returns</dt><dd>true if interface is available, false otherwise. </dd></dl>

</div>
</div>
<a id="a59e7ea08d55ba05bc1039eac996feb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e7ea08d55ba05bc1039eac996feb7b">&#9670;&nbsp;</a></span>state_interface_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; hardware_interface::ResourceManager::state_interface_keys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all registered state interfaces keys. </p>
<p>The keys are collected from each loaded hardware component. </p><dl class="section return"><dt>Returns</dt><dd>Vector of strings, containing all registered keys. </dd></dl>

</div>
</div>
<a id="a5b97b997de12432dcbfbabcedca2a52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b97b997de12432dcbfbabcedca2a52e">&#9670;&nbsp;</a></span>system_components_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hardware_interface::ResourceManager::system_components_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of loaded system components. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t number of system components. </dd></dl>

</div>
</div>
<a id="af2cbef1c78b8b5357c0b8e8d97cb077e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cbef1c78b8b5357c0b8e8d97cb077e">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhardware__interface_1_1HardwareReadWriteStatus.html">HardwareReadWriteStatus</a> hardware_interface::ResourceManager::write </td>
          <td>(</td>
          <td class="paramtype">const rclcpp::Time &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const rclcpp::Duration &amp;&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write all loaded hardware components. </p>
<p>Writes to all active hardware components.</p>
<p>Part of the real-time critical update loop. It is realtime-safe if used hardware interfaces are implemented adequately. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ros2_control/hardware_interface/include/hardware_interface/<a class="el" href="resource__manager_8hpp_source.html">resource_manager.hpp</a></li>
<li>ros2_control/hardware_interface/src/resource_manager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
